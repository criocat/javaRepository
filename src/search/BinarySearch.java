package search;

public class BinarySearch {

    //pred: a != null
    private static int IterateBinarySearch(int x, int[] a) {
        int l = -1, r = a.length;
        // r - подходящий индекс
        // R <= r
        // R >= 0
        // R принадлежин (l, r]
        // обозначим значение r' - l' до итерации цикла за p, после за p'
        // inv: R принадлежит (l', r'] && p' <= p - 1
        while (r - l > 1) {
            // R принадлежит (l', r']
            // r' > l'
            // r' > l' + 1
            // r' >= l' + 2
            int m = (l + r) / 2;
            // m принадлежит [l' + 1, r' - 1]
            // m принадлежит [l + 1, r - 1]
            // m принадлежит [0, a.length - 1]
            if (a[m] <= x) {
                // a[m] <= x
                // m - какой-то подходящий индекс
                // R <= m
                // R принадлежит (l', r']
                // R принадлежит (l', m]
                // p' = m - l' <= r' - 1 - l' = p - 1
                r = m;
                // R принадлежит (l', r'] && p' <= p - 1
            }
            else {
                // a[m] > x
                // m - неподходящий индекс
                // R > m
                // R принадлежит (l', r']
                // R принадлежит (m, r']
                // p' = r' - m <= r' - (l' + 1) = p - 1
                l = m;
                // R принадлежит (l', r'] && p' <= p - 1
            }
            // R принадлежит (l', r'] && p' <= p - 1
        }
        // когда p' <= 1 цикл прекращается, p' = r' - l' конечен и с каждой итерацией цикла убывает => цикл конечен => функция завершится
        // r' - l' <= 1
        // R принадлежит (l', r']
        // post: r' - l' == 1

        // R принадлежит (r' - 1, r']
        // R = r'
        return r;
    }
    // post: R = минимальный j : x >= a[j]




    // pred: a != null && R принадлежит (l, r]
    private static int RecursiveBinarySearch(int x, int[] a, int l, int r) {
        // // обозначим  r - l за p, a r' - l' за p'
        if (r - l == 1) {
            // R принадлежит (r - 1, r]
            // R = r
            // рекурсивно вызвались 0 раз
            return r;
        } else {
            // R принадлежит (l, r]
            // r >= l + 1
            // r != l + 1
            // r >= l + 2
            int m = (l + r) / 2;
            // m принадлежит [l + 1, r - 1]
            // m принадлежит [0, a.length - 1]
            if (a[m] <= x) {
                // a[m] <= x
                // m - какой-то подходящий индекс
                // R <= m
                // R принадлежит (l, r]
                // R принадлежит (l, m]
                // p' = m - l <= r - 1 - l = p - 1
                r = m;
                // R принадлежит (l', r'] && p' <= p - 1
            }
            else {
                // a[m] > x
                // m - неподходящий индекс
                // R > m
                // R принадлежит (l, r]
                // R принадлежит (m, r]
                // p' = r - m <= r - (l + 1) = p - 1
                l = m;
                // R принадлежит (l', r'] && p' <= p - 1
            }
            // R принадлежит (l', r'] && p' <= p - 1
            // a != null
            // предусловия функции выполнены
            return RecursiveBinarySearch(x, a, l, r);
            // рекурсивно вызвались 1 раз от меньшего полуинтервала
            // вернет R
        }
        // рекурсивно вызвали функцию от меньшего интервала не более 1 раза
    }
    // post: R = минимальный j : x >= a[j]; функция рекурсивно вызвалась не больше одного раза от меньшего полуинтервала

    // по индукции докажем что если выполняется предусловие то функция работает за конечное время
    // p = r - l
    // база: p = 1: функция пройдет по ветке без рекурсии и завершится
    // переход: пусть для p <= x функция когда-то завершится, если запустить функцию от полуинтервала длины x + 1, то из постусловия следуе
    //      что функция не больше одного раза вызовется от полуинтервала длины x, что происходит за конечное время, так как это единственное
    //      место где функция может работать бесконечно долго, то функция будет работать за конечное время






    // считаем что последний элемент массива a это минус бесконечность, его мы не передаем в main
    // pred: на вход подается набор целых чисел длины >= 1 (число x, элементы массива a)
    public static void main(String[] args) {
        int x = Integer.parseInt(args[0]);
        // подалось хотябы 1 целове число поэтому ошибки не будет
        int[] a = new int[args.length - 1];
        // args.length - 1 >= 0 т.е. ошибки не будет
        for (int i = 0; i < args.length - 1; ++i) {
            // 0 <= i <= a.length - 1
            // 1 <= i + 1 <= args.length - 1
            // выхода за границы не произойдет и мы считаем все значения из входных данных кроме первого в массив a
            a[i] = Integer.parseInt(args[i + 1]);
        }
        // R > -1
        // a.length - подходящий индекс
        // R <= a.length
        // a != null && R принадлежит (-1, a.length]
        System.out.println(RecursiveBinarySearch(x, a, -1, a.length));
        // выведет R
    }
    // post: выведет такой минимальный j что x >= a[j]
}
