package search;

public class BinarySearchShift {

    //pred: a != null && func != null &&  func и массив a задают неубывающую функцию на полуинтервале [l, r)
    private static int iterateBinarySearch(int x, int[] a, int l, int r, ArrayHull func) {
        // за a[m] обозначим func(a[m])
        // R - подходящий индекс
        // R принадлежин (l, r]
        // обозначим значение r' - l' за p
        // inv: R принадлежит (l', r'] && p' <= (p / 2) округленное вверх
        while (r - l > 1) {
            // R принадлежит (l', r']
            // r' > l'
            // r' > l' + 1
            // r' >= l' + 2
            int m = (l + r) / 2;
            // m принадлежит [l' + 1, r' - 1]
            // m принадлежит [l + 1, r - 1]
            if (func.getVal(a[m]) >= x) {
                // a[m] >= x
                // m - какой-то подходящий индекс
                // R <= m
                // R принадлежит (l', r']
                // R принадлежит (l', m]
                // p' = m - l' =  (l' + r') / 2 - l' <= (l' - r') / 2 округленное вверх = (p / 2) округленное вверх
                r = m;
                // R принадлежит (l', r'] && p' <= (p / 2) округленное вверх
            } else {
                // a[m] < x
                // m - неподходящий индекс
                // R > m
                // R принадлежит (l', r']
                // R принадлежит (m, r']
                // p' = r' - m <= r' - (l' + r') / 2 <= (l' - r') / 2 округленное вверх = (p / 2) округленное вверх
                l = m;
                // R принадлежит (l', r'] && p' <= (p / 2) округленное вверх
            }
            // R принадлежит (l', r'] && p' <= p - 1
        }
        // когда p' <= 1 цикл прекращается, p' = r' - l' конечен и с каждой итерацией p' = (p / 2) округленное
        // вверх => цикл отработает <= lon(r' - l') округленное вверх раз
        // r' - l' <= 1
        // R принадлежит (l', r']
        // post: r' - l' == 1

        // R принадлежит (r' - 1, r']
        // R = r'
        return r;
    }
    // post: R = минимальный j : x <= a[j]


    //pred: a != null && func != null &&  func и массив a задают неубывающую функцию на полуинтервале [l, r)
    private static int recursiveBinarySearch(int x, int[] a, int l, int r, ArrayHull func) {
        // за a[m] обозначим func(a[m])
        // обозначим значение r' - l' за p
        if (r - l == 1) {
            // R принадлежит (r - 1, r]
            // R = r
            // рекурсивно вызвались 0 раз
            return r;
        } else {
            // R принадлежит (l, r]
            // r >= l + 1
            // r != l + 1
            // r >= l + 2
            int m = (l + r) / 2;
            // m принадлежит [l + 1, r - 1]
            // m принадлежит [0, a.length - 1]
            if (func.getVal(a[m]) >= x) {
                // a[m] >= x
                // m - какой-то подходящий индекс
                // R <= m
                // R принадлежит (l, r]
                // R принадлежит (l, m]
                // p' = m - l' =  (l' + r') / 2 - l' <= (l' - r') / 2 округленное вверх = (p / 2) округленное вверх
                r = m;
                // R принадлежит (l', r'] && (p / 2) округленное вверх
            } else {
                // a[m] < x
                // m - неподходящий индекс
                // R > m
                // R принадлежит (l, r]
                // R принадлежит (m, r]
                // p' = r' - m <= r' - (l' + r') / 2 <= (l' - r') / 2 округленное вверх = (p / 2) округленное вверх
                l = m;
                // R принадлежит (l', r'] && p' <= (p / 2) округленное вверх
            }
            // R принадлежит (l', r'] && p' <= (p / 2) округленное вверх
            // a != null && func != null
            // func и массив a задают неубывающую функцию на полуинтервале [l, r)
            // предусловия функции выполнены
            return recursiveBinarySearch(x, a, l, r, func);
            // рекурсивно вызвались 1 раз от меньшего полуинтервала
            // вернет R
        }
        // рекурсивно вызвалась не более 1 раза от интервала размера <= (p / 2) округленное вверх
    }
    // post: R = минимальный j : x >= a[j]; функция рекурсивно вызвалась не больше одного раза от интервала размера <= (p / 2) округленное вверх
    // так как функция рекурсивно вызвалась не больше одного раза от полуинтервала размера <= (p / 2) округленное вверх то количество рекурсивных запусков будет <= log(r - l) округленное вверх



    // считаем что последний элемент массива a это плюс бесконечность, его мы не передаем в main
    // j назовем подходящим индексом если x <= a[j]

    // pred: на вход подается набор целых чисел длины >= 1 (число x, элементы массива a) и a - циклически сдвинутый строго возрастающий массив
    public static void main(String[] args) {
        int x = Integer.parseInt(args[0]);
        // подалось хотябы 1 целове число поэтому ошибки не будет
        int[] a = new int[args.length - 1];
        int n = a.length;
        // args.length - 1 >= 0 т.е. ошибки не будет
        for (int i = 0; i < args.length - 1; ++i) {
            // 0 <= i <= a.length - 1
            // 1 <= i + 1 <= args.length - 1
            // выхода за границы не произойдет и мы считаем все значения из входных данных кроме первого в массив a
            a[i] = Integer.parseInt(args[i + 1]);
        }
        // a != null && func != null && func и массив a задают неубывающую функцию на полуинтервале[ 0, n)
        // которая представляет собой последовательность из сначала нулей потом единиц, при этом первая 1
        // (если она существует) определяет смещение массива a
        int pos = iterateBinarySearch(1, a, 0, n, (val) -> (val > a[0] ? 0 : 1));
        // в pos будет индекс первого элемента после границы смещения

        int ans = -1;
        if (pos == n) {
            // pos == n означает что массив не был циплически сдвинут
            int posl = iterateBinarySearch(x, a, -1, n, (val) -> val);
            // если в массиве было x, то a[pos] == x
            // если в массиве не было x, то pos == n или a[pos] != x
            if (posl != n && a[posl] == x) ans = posl;
        } else {
            // если pos != n то элементы на отрезке [0, pos - 1] и [pos, n - 1] возрастают и суммарно образовывают весь массив
            int posl = iterateBinarySearch(x, a, -1, pos, (val) -> val);
            // если в левом подмассиве было x, то a[posl] == x
            // если в провом подмассиве не было x, то posl == pos или a[posl] != x
            int posr = iterateBinarySearch(x, a, pos - 1, n, (val) -> val);
            // если в правом подмассиве было x, то a[posr] == x
            // если в правом подмассиве не было x, то posr == n или a[posr] != x
            if (posl != pos + 1 && a[posl] == x) {
                ans = posl;
            }
            if (posr != n && a[posr] == x) {
                ans = posr;
            }
            // если в массиве есть x то в индексах posl или posr лежит x, и в ans будет индекс соответствующий x;
            // если в массиве не было x то ни одно из условий не сработает и ans останется -1
        }
        System.out.println(ans);
    }
    // post: если x в массиве a: выведет такой j что x == a[j]
    // если x нет в a то выведет -1
}
